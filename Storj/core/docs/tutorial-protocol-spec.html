<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Tutorial: Protocol Specification</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Tutorial: Protocol Specification</h1>

    <section>

<header>
    

    <h2>Protocol Specification</h2>
</header>

<article>
    <p>Nodes communicate with each other using
<a href="http://www.jsonrpc.org/specification">JSON-RPC 2.0</a> over HTTPS. This requires
farmers (nodes who are contracted by renter to store data) to be publicly
addressable and enables access to content from web browsers, mobile phones, and
any other devices that speak HTTP (hint: everything).</p>
<p>This document outlines the specification for the RPC interface by defining the
message structure, required methods, and expected response formats that are
needed for a Storj protocol compliant implementation.</p>
<blockquote>
<p>Note that there may be other aspects of the protocol that are implemented as
SIPs (Storj Improvement Proposals). See the end of this document for a list
of implemented SIPs.</p>
</blockquote>
<h3>Request Format</h3>
<p>Requests are formed according to the JSON-RPC 2.0 specification and are issued
via HTTP POST. The Storj protocol requires the use of <em>named parameters</em> -
positional parameters are not supported. Example:</p>
<pre class="prettyprint source"><code>{
  &quot;method&quot;: &quot;PING&quot;,
  &quot;params&quot;: {
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.2&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;89cc3ddb4209c6e7e301c10c0257adf4fd85f253&quot;,
      &quot;protocol&quot;: &quot;0.8.1&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;3045022100de2e162d017a1e9d0ebfe2a94df3fc847b68281a9882...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}
</code></pre>
<p>The receiving node for this request would then respond with the result, which
in the case of a <code>PING</code> message, is simply an acknowledgement that includes
the recipient's contact information and required <code>signature</code> and <code>nonce</code>:</p>
<pre class="prettyprint source"><code>{
  &quot;result&quot;: {
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.3&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.8.1&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}
</code></pre>
<p>In the event that an error occurs, an <code>error</code> property must be <em>added</em> to the
response. You <em>still</em> need to include your <code>contact</code> data in the <code>result</code>
property of the response:</p>
<pre class="prettyprint source"><code>{
  &quot;result&quot;: {
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.3&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.8.1&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;error&quot;: {
    &quot;code&quot;: -32603,
    &quot;message&quot;: &quot;OH GOD THERE'S SO MUCH BLOOD&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}
</code></pre>
<h3>Joining the Network</h3>
<p>To join the Storj network, one must only know the contact information for a
single &quot;seed&quot; node. A node's contact information is defined as the following
three properties:</p>
<ul>
<li><code>address</code> - hostname, domain, or IP</li>
<li><code>port</code> - port number on which the node is listening</li>
<li><code>nodeID</code> - hash of the node's public key (see below)</li>
<li><code>protocol</code> - version of the protocol implementation</li>
</ul>
<p>This information can be expressed as a URI in the following format:</p>
<pre class="prettyprint source"><code>storj://10.0.0.2:1337/89cc3ddb4209c6e7e301c10c0257adf4fd85f253
</code></pre>
<p>In addition to knowing this information about the seed, you also will need to
know this information about yourself, so that it can be provided to the nodes
with which you are communicating. Your &quot;contact card&quot; must be provided as the
<code>contact</code> parameter in every message sent (both requests and responses). This
is because messages must be signed with your private key and your <code>nodeID</code> is
used by recipients to verify two things:</p>
<ol>
<li>That you own the private key corresponding to your claimed <code>nodeID</code></li>
<li>That the message was in fact sent by you and not an attacker</li>
</ol>
<p>In the Storj network, nodes are identified by the hash of the public portion of
an ECDSA key pair. Key pairs are generated using curve SECP256K1 and a node's
<code>nodeID</code> is the &quot;pubkeyhash&quot;, defined as:</p>
<pre class="prettyprint source"><code>RIPEMD160(SHA256(public_key))
</code></pre>
<p>This pubkeyhash, combined with a message and signature is enough data to
reconstruct the complete public key and is used in the Storj network to sign
and verify messages. This ensures that nodes are unable to assume the identity
of another node by claiming it has the same <code>nodeID</code>.</p>
<h4>Special Headers</h4>
<h5><code>x-storj-node-id</code></h5>
<p>Every request sent should include this header. It's value should equal the
expected Node ID of the destination. This allows nodes who are tunneling
other nodes to determine who the message is intended for.</p>
<h4>PROBE</h4>
<p>Before a node can join the network, it must determine whether or not it is
reachable (or <em>publicly addressable</em>). This can be determined by sending a
<code>PROBE</code> request to a known seed.</p>
<pre class="prettyprint source"><code>{
  &quot;method&quot;: &quot;PROBE&quot;,
  &quot;params&quot;: {
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.3&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.6.0&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}
</code></pre>
<p>The <code>PROBE</code> RPC message triggers the recipient to attempt to reach the
supplied <a href="Contact.html">Contact</a> directly by sending a <code>PING</code> RPC message. If the
target <a href="Contact.html">Contact</a> reponds to the <code>PING</code>, then the <code>PROBE</code> should yield
a success response, which is indicated by simply responding to the RPC
message with only the required parameters and <strong>no</strong> <code>error</code> property.</p>
<pre class="prettyprint source"><code>{
  &quot;result&quot;: {
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.3&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.6.0&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}
</code></pre>
<p>If the <code>PING</code> message triggered by the <code>PROBE</code> fails, then the recipient of the
<code>PROBE</code> RPC must respond with an error indicating to the sender that she is not
addressable.</p>
<pre class="prettyprint source"><code>{
  &quot;result&quot;: {
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.3&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.6.0&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;error&quot;: {
    &quot;code&quot;: -32603,
    &quot;message&quot;: &quot;PROBE FAILED&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}
</code></pre>
<p>If the <code>PROBE</code> fails, you cannot successfully join the overlay and need to
establish a <strong>tunnel</strong> through a node that <em>is</em> addressable on the network.</p>
<h4>FIND_TUNNEL</h4>
<p>Finding a node that is willing to tunnel your connection to the overlay begins
with a <code>FIND_TUNNEL</code> RPC message sent to a known seed. Nodes on the network
maintain a record of known nodes that are willing to tunnel, by subscribing to
&quot;tunnel announcements&quot; over the publish/subscribe system.</p>
<blockquote>
<p>For more information on how nodes announce willingness to tunnel, see the
documentation for <a href="tutorial-tunnel-connections.html">Tunnelling Connections</a>.</p>
</blockquote>
<pre class="prettyprint source"><code>{
  &quot;method&quot;: &quot;FIND_TUNNEL&quot;,
  &quot;params&quot;: {
    &quot;relayers&quot;: [],
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.3&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.8.1&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}
</code></pre>
<p>When a node receives a <code>FIND_TUNNEL</code> message, it should respond with <code>ALPHA</code>
(3) contacts that are close the the sender's <code>nodeID</code> who have previously
published their willingness to tunnel. If the recipient herself is willing to
tunnel the connection, she may include herself in the response even if her
<code>nodeID</code> is not closer to the sender's <code>nodeID</code> than her known tunnels.</p>
<pre class="prettyprint source"><code>{
  &quot;result&quot;: {
    &quot;tunnels&quot;: [
      {
        &quot;address&quot;: &quot;10.0.0.4&quot;,
        &quot;port&quot;: 1337,
        &quot;nodeID&quot;: &quot;58dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
        &quot;protocol&quot;: &quot;0.6.0&quot;
      },
      {
        &quot;address&quot;: &quot;10.0.0.5&quot;,
        &quot;port&quot;: 1337,
        &quot;nodeID&quot;: &quot;68dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
        &quot;protocol&quot;: &quot;0.6.0&quot;
      },
      {
        &quot;address&quot;: &quot;10.0.0.6&quot;,
        &quot;port&quot;: 1337,
        &quot;nodeID&quot;: &quot;78dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
        &quot;protocol&quot;: &quot;0.6.0&quot;
      }
    ],
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.3&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.6.0&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}
</code></pre>
<p>The result of a <code>FIND_TUNNEL</code> message looks almost identical to the result of a
<code>FIND_NODE</code> message, with the exception being the name of the result key is
<code>tunnels</code> instead of <code>nodes</code>. Now that the original sender possesses the
contact information for some known tunnels, she should keep them in her record
so that she can later respond to other's <code>FIND_TUNNEL</code> requests appropriately.</p>
<p>Before the node can join the overlay (after determining it is not publicly
addressable), it needs to establish a connection tunnel through one of the
<a href="Contact.html">Contact</a>s received from the <code>FIND_TUNNEL</code> request.</p>
<h4>OPEN_TUNNEL</h4>
<p>Establishing a tunnel is initiated by sending an <code>OPEN_TUNNEL</code> RPC message to a
node who has indicated their willingness to tunnel. Only the minimum required
parameters need to be sent.</p>
<blockquote>
<p>In the future, the protocol may be enhanced to include additional information
in the <code>OPEN_TUNNEL</code> RPC for negotiating payment channels or other conditions.</p>
</blockquote>
<pre class="prettyprint source"><code>{
  &quot;method&quot;: &quot;OPEN_TUNNEL&quot;,
  &quot;params&quot;: {
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.3&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;1.0.0&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}
</code></pre>
<p>The recipient of the <code>OPEN_TUNNEL</code> message must determine whether or not she
can satisfy the request. This decision may be based upon an arbitrary limit
set by the node regarding how many concurrent tunnels she wishes to open,
available bandwidth, etc. If the node is capable of establishing the tunnel,
she must do so, assigning a dedicated address or port to receive messages and
data channel requests (see data-channels).</p>
<p>Once the tunnel's dedicated entry point has been established, she responds to
the sender of the <code>OPEN_TUNNEL</code> request with a <code>proxyPort</code> to which the client
may connect to receive messages.</p>
<pre class="prettyprint source"><code>{
  &quot;result&quot;: {
    &quot;proxyPort&quot;: 12000,
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.3&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;1.0.0&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}
</code></pre>
<p>This response indicates that a proxy has been established and the original
sender can receive messages from the overlay by opening a TCP connection
to the <code>proxyPort</code> and contact address in the reply. In addition, the sender
must update it's <a href="Contact.html">Contact</a> information to mirror the remote tunneler's
address and port.</p>
<p>If the recipient of the <code>OPEN_TUNNEL</code> message is not able to establish a tunnel
for the sender, then she may respond with an error so that the sender can
attempt to open a tunnel with other known contact.</p>
<pre class="prettyprint source"><code>{
  &quot;result&quot;: {
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.3&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.6.0&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;error&quot;: {
    &quot;code&quot;: -32603,
    &quot;message&quot;: &quot;Failed to establish tunnel, multiplexer full&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}
</code></pre>
<p>Once your node has determined that it is publicly addressable on the network
or has successfully established a tunnel, it can join the overlay network by
issuing a <code>FIND_NODE</code> request sent to one or more known seeds. The request must
include a <code>key</code>, <code>contact</code> (you), along with a <code>signature</code> and <code>nonce</code>.</p>
<h4>FIND_NODE</h4>
<p>When issuing a <code>FIND_NODE</code> request, you provide a <code>key</code> that represents the
<code>nodeID</code> of the contact of which you would like to know their neighbors. When
joining the network, this value is <em>your own <code>nodeID</code></em>.</p>
<pre class="prettyprint source"><code>{
  &quot;method&quot;: &quot;FIND_NODE&quot;,
  &quot;params&quot;: {
    &quot;key&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.3&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.8.1&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}
</code></pre>
<p>When a node receives a <code>FIND_NODE</code> RPC message, it must perform a lookup in
it's routing table and respond with a <code>nodes</code> array containing the known
contacts that are &quot;closest&quot; to the provided key. This is based on the XOR
metric as the Storj network uses a
<a href="https://en.wikipedia.org/wiki/Kademlia">Kademlia</a>-based overlay. In addition,
if the receiving node is not already aware of the requesting node, it may add
the requester to it's own routing table to later inform other requesters.</p>
<pre class="prettyprint source"><code>{
  &quot;result&quot;: {
    &quot;nodes&quot;: [
      {
        &quot;address&quot;: &quot;10.0.0.4&quot;,
        &quot;port&quot;: 1337,
        &quot;nodeID&quot;: &quot;58dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
        &quot;protocol&quot;: &quot;0.8.1&quot;
      },
      {
        &quot;address&quot;: &quot;10.0.0.5&quot;,
        &quot;port&quot;: 1337,
        &quot;nodeID&quot;: &quot;68dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
        &quot;protocol&quot;: &quot;0.8.1&quot;
      },
      {
        &quot;address&quot;: &quot;10.0.0.6&quot;,
        &quot;port&quot;: 1337,
        &quot;nodeID&quot;: &quot;78dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
        &quot;protocol&quot;: &quot;0.8.1&quot;
      }
    ],
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.3&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.8.1&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}
</code></pre>
<p>Upon receipt of the <code>FIND_NODE</code> response, the node attempting to join the
network may iteratively send the same <code>FIND_NODE</code> request to contacts that have
been newly added to the routing table to build out a wider view of the network.
Once the joining node is satisfied with the size of the routing table (or there
are no more nodes to discover), this is considered a successful join.</p>
<h3>Soliciting Storage</h3>
<p>Once a node has a sufficiently complete routing table and view of the network,
it's time to buddy up with it's neighbors to cooperate in the sharing and relay
of publications. A &quot;publication&quot; is essentially a <strong>request for storage</strong>. When
a node in the network wishes to store some data, it notifies it's closest
neighbors who, if interested, will respond to negotiate a storage contract.</p>
<p>If the neighbors are not offering storage or do not wish to fulfill the terms of
the storage contract, they must check to see if any of their neighbors are and
forward the publication to them. If no known neighbors are interested, then the
publication is sent to a random node in that neighbor's routing table and the
process repeats until an interested node fulfills the contract.</p>
<h4>SUBSCRIBE</h4>
<p>In order to know what publications in which your neighbors are interested, we
select the 3 nodes in our routing table that are identified by a <code>nodeID</code> that
is closest to ours and we issue a <code>SUBSCRIBE</code> message to each of them:</p>
<pre class="prettyprint source"><code>{
  &quot;method&quot;: &quot;SUBSCRIBE&quot;,
  &quot;params&quot;: {
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.2&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.8.1&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}
</code></pre>
<p>To properly handle a <code>SUBSCRIBE</code> message, the recipient must respond with an
<em>attenuated bloom filter</em>, with a size 160 bits and a depth of 3. This data
structure represents 3 sets of topics to which the recipient's neighbors are
subscribed 3 &quot;hops&quot; away.</p>
<pre class="prettyprint source"><code>{
  &quot;result&quot;: {
    &quot;filters&quot;: [
      &quot;0000000000000000000000000000000000000000&quot;,
      &quot;0000000000000000000000000000000000000000&quot;,
      &quot;0000000000000000000000000000000000000000&quot;
    ],
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.3&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;58dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.8.1&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}
</code></pre>
<p>When the original requesting node receives this response, it must update it's
local attenuated bloom filter to reflect this response, starting at it's filter
at index <code>1</code> (since index <code>0</code> is reserved for topic to which the node itself is
interested).</p>
<h4>UPDATE</h4>
<p>After the requester updates it's local view of it's neighbor's publication
subscriptions, it must in turn update it's neighbors with it's own publication
subscriptions by providing it's own attenuated bloom filter:</p>
<pre class="prettyprint source"><code>{
  &quot;method&quot;: &quot;UPDATE&quot;,
  &quot;params&quot;: {
    &quot;filters&quot;: [
      &quot;0000000000000000000000000000000000000000&quot;,
      &quot;0000000000000000000000000000000000000000&quot;,
      &quot;0000000000000000000000000000000000000000&quot;
    ],
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.2&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.8.1&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}
</code></pre>
<p>This method is essentially the &quot;push&quot; version of the <code>SUBSCRIBE</code> message, where
instead of providing subscription information as a response, we provide it as a
request. Whenever a node subscribes to a new publication topic, it should
initiate another <code>SUBSCRIBE</code>/<code>UPDATE</code> loop with it's neighbors to ensure that
it may cooperate in publication relay effectively.</p>
<h4>PUBLISH</h4>
<p>Once a node has a view of the publications to which it's neighbors are
subscribed, it is capable of issuing a <code>PUBLISH</code> message containing a <code>topic</code>
and some <code>content</code>. This message is sent to the node's nearest neighbors, who
then relay it to their neighbors based upon their own view of nearby
subscriptions.</p>
<p>The <code>topic</code> property and the corresponding <code>contents</code> data is arbitrary, but
this mechanism is used for publishing &quot;asks&quot; for storage contracts. In this
case, the <code>topic</code> is equal to the <a href="Contract.html">Contract</a> type and the <code>contents</code> is
equal to the proposed contract itself. See <a href="tutorial-contract-topics.html">Publishing Storage Contracts</a> for more
information on how to choose a valid contract type for your storage needs.</p>
<pre class="prettyprint source"><code>{
  &quot;method&quot;: &quot;PUBLISH&quot;,
  &quot;params&quot;: {
    &quot;uuid&quot;: &quot;7f0c40a2-e465-4f3e-b617-3d53460e34f7&quot;,
    &quot;topic&quot;: &quot;0f02010303&quot;,
    &quot;contents&quot;: {
      &quot;type&quot;: &quot;56ce3e837f575827cb5a94e2b609756a48fa4a3882f5e762b262af31f432878d&quot;,
      &quot;renter_id&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;renter_signature&quot;: null,
      &quot;farmer_id&quot;: null,
      &quot;farmer_signature&quot;: null,
      &quot;data_size&quot;: 4906,
      &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;,
      &quot;store_begin&quot;: 1455228907665,
      &quot;store_end&quot;: 2910457830468,
      &quot;audit_count&quot;: 10,
      &quot;payment_storage_price&quot;: 1200,
      &quot;payment_download_price&quot;: 2,
      &quot;payment_destination&quot;: null
    },
    &quot;publishers&quot;: [
      &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;
    ],
    &quot;ttl&quot;: 1455228597837,
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.2&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.8.1&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}
</code></pre>
<p>Upon receipt of a <code>PUBLISH</code> message, a node must first check to make sure it
has not already received the publication. This is done by caching the <code>uuid</code> of
received publications. If the node has already seen the publication, it should
respond with an error message indicating such. The node should also make sure
that the publication has not expired by checking that the <code>ttl</code> is a positive
integer.</p>
<p>If the node has not previously seen the publication and the message has not
expired, then it must check to see if the publication topic is of interest to
itself by testing it's attenuated bloom filter at index <code>0</code> for the topic. If
the node is interested in the publication, it may take action accordingly. In
the case of storage contract, the node may begin communicating directly with
the original publisher to finalize the contract.</p>
<p>Regardless of whether or not the node is interested in the publication, it
should acknowledge receipt of the publication to the forwarder:</p>
<pre class="prettyprint source"><code>{
  &quot;result&quot;: {
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.2&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.8.1&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}
</code></pre>
<p>Then, it must append <em>negative information</em> to the publication message by
adding it's own <code>nodeID</code> to the <code>publishers</code> property as well as decrementing
the <code>ttl</code>. Once the message has been updated with the negative information,
the node must check it's attenuated bloom filter to see if any of it's
neighbors are also interested and, if so, forward the message along to them.
If no neighbors are interested, the node must select a random contact from the
routing table and forward the message to that contact.</p>
<h3>Negotiating Storage Contracts</h3>
<p>When a node receives a contract proposal in the form of a <code>PUBLISH</code> message and
that proposal meets the recipient's criteria, it can send an <code>OFFER</code> message to
the original publisher.</p>
<h4>OFFER</h4>
<p>The offer message must contain the original contract, supplemented with the
information that is required of the offering node, which at minimum must
include <code>farmer_id</code>, <code>farmer_signature</code>, and <code>payment_destination</code>.</p>
<blockquote>
<p>The <code>*_signature</code> property value should be the hex-encoded signature of the
JSON string representation of the contract, minus both signature fields and
with keys sorted alphanumerically.</p>
</blockquote>
<p>In addition to these fields, the offering node (or &quot;farmer&quot;) may modify the
other fields in the contract to their liking if they wish to counter the
original offer:</p>
<pre class="prettyprint source"><code>{
  &quot;method&quot;: &quot;OFFER&quot;,
  &quot;params&quot;: {
    &quot;contract&quot;: {
      &quot;type&quot;: &quot;56ce3e837f575827cb5a94e2b609756a48fa4a3882f5e762b262af31f432878d&quot;,
      &quot;renter_id&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;renter_signature&quot;: null,
      &quot;farmer_id&quot;: &quot;58dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;farmer_signature&quot;: &quot;304502203f2be986f4213c45bf2f78c57cbf4001b049c4fd...&quot;,
      &quot;data_size&quot;: 4906,
      &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;,
      &quot;store_begin&quot;: 1455228907665,
      &quot;store_end&quot;: 2910457830468,
      &quot;audit_count&quot;: 10,
      &quot;payment_storage_price&quot;: 1200,
      &quot;payment_download_price&quot;: 2,
      &quot;payment_destination&quot;: &quot;1JUhMAZj2Mkb4mRaGxbBYPsStryPyDxPuj&quot;
    },
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.2&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.8.1&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}
</code></pre>
<p>The receiving node must check the offer and determine whether or not the
modified contract terms are satisfactory. If so, it may finalize the contract
by adding it's signature to the <code>renter_signature</code> field:</p>
<pre class="prettyprint source"><code>{
  &quot;result&quot;: {
    &quot;contract&quot;: {
      &quot;type&quot;: &quot;56ce3e837f575827cb5a94e2b609756a48fa4a3882f5e762b262af31f432878d&quot;,
      &quot;renter_id&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;renter_signature&quot;: &quot;304402202ccc152ee81fbff7e802c290cabea0c62384bb12...&quot;,
      &quot;farmer_id&quot;: &quot;58dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;farmer_signature&quot;: &quot;304502203f2be986f4213c45bf2f78c57cbf4001b049c4fd...&quot;,
      &quot;data_size&quot;: 4906,
      &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;,
      &quot;store_begin&quot;: 1455228907665,
      &quot;store_end&quot;: 2910457830468,
      &quot;audit_count&quot;: 10,
      &quot;payment_storage_price&quot;: 1200,
      &quot;payment_download_price&quot;: 2,
      &quot;payment_destination&quot;: &quot;1JUhMAZj2Mkb4mRaGxbBYPsStryPyDxPuj&quot;
    },
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.2&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.8.1&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}
</code></pre>
<p>Alternatively, the receiving node may counter the offer by modifying any of the
fields and returning those in the response. The farmer must check the contract
against it's signature to determine if the terms of the contract have been
changed. This counter offer loop can continue until one party abandons the
offer loop or until both parties have signed the same contract.</p>
<blockquote>
<p>Once a contract has been finalized, each node should store a copy locally
that can be keyed by the <code>data_hash</code>.</p>
</blockquote>
<h3>Executing a Storage Contract</h3>
<p>Once a storage contract has been signed by both parties, the renter may execute
the terms of the contract by issuing a <code>CONSIGN</code> message to the farmer. The
purpose of this message is to deliver the data referenced by the contract for
the farmer to store.</p>
<h4>CONSIGN</h4>
<p>The consign message must contain the hex-encoded
<code>data_shard</code> itself, the <code>contract_hash</code>, as well as an <code>audit_tree</code> that
contains the bottom leaves of the audit strategy's merkle tree (see <strong>Auditing
a Storage Contract</strong> below).</p>
<pre class="prettyprint source"><code>{
  &quot;method&quot;: &quot;CONSIGN&quot;,
  &quot;params&quot;: {
    &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;,
    &quot;audit_tree&quot;: [
      &quot;40a98e19c298631cba19d6c19691360ce08ccf36&quot;,
      &quot;02f0d971096305e797da9165cd50d4d1bb19590b&quot;,
      &quot;a44ad75d8aa118cdd73df77ae2543d3e87f94576&quot;,
      &quot;d84e8bfac28a98df418d0c3029f77a4d9f338e9e&quot;,
      &quot;7408bb5b0a9eefa56f3234fc83d2423f76c4b857&quot;,
      &quot;d1b71886c910d34b31cee9e23316abded9ef3fe0&quot;,
      &quot;0ac89686a12e26aaf952180c0fec5373224c4c1e&quot;,
      &quot;98c304116e7eb89839ff6c96202eb4c3cbdaf8e0&quot;,
      &quot;c7937b8a1be9da426e076eff70c5b4edf8a66270&quot;,
      &quot;c6c2c5cdafb99e4d62185d42e59522d15c33d676&quot;,
      &quot;1f87ca29e75944aa36e676b3ddf27e49a8ca4fe2&quot;,
      &quot;8585e356a517535b8a36ec9222b955c5b61a5227&quot;,
      &quot;ba084d3f143f2896809d3f1d7dffed472b39d8de&quot;,
      &quot;ba084d3f143f2896809d3f1d7dffed472b39d8de&quot;,
      &quot;ba084d3f143f2896809d3f1d7dffed472b39d8de&quot;,
      &quot;ba084d3f143f2896809d3f1d7dffed472b39d8de&quot;
    ],
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.2&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.8.1&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}
</code></pre>
<p>Upon receipt of a <code>CONSIGN</code> message, the farmer must lookup the reference
contract by the supplied <code>data_hash</code> and verify that the renter is authorized
to store the data and that the number of items in the <code>audit_tree</code> is equal to
the next power of 2 of the <code>audit_count</code> supplied in the original contract.</p>
<p>Once verified, the farmer must respond with a generated token that the renter
or another authorized party can use to open a data channel with the farmer
(via websocket) to deliver the data as a binary stream.</p>
<blockquote>
<p>For more information on the Data Channel specification see the tutorial for
data-channels.</p>
</blockquote>
<p>In addition, the farmer should verify that the current UNIX time is greater
than or equal to the agreed upon <code>store_begin</code> and less than the agreed upon
<code>store_end</code>. If everything checks out, the farmer must store the consigned data
in such a way that it may later be retrieved by it's hash. Once the farmer has
done this, it must acknowledge the renter to confirm:</p>
<pre class="prettyprint source"><code>{
  &quot;result&quot;: {
    &quot;token&quot;: &quot;3f62b781e3b5b5288dca587807248261d109bbfb&quot;,
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.2&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.8.1&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}
</code></pre>
<h3>Using Mirrors for Redundancy</h3>
<p>In most cases it is desirable for the renter to store multiple copies of the
shard across a number of farmers in the event that one of the contracted
farmers leaves the network, loses the data, or otherwise breaches the terms of
the storage contract. This can be accomplished by simply performing an
iterative <code>PUBLISH - OFFER - CONSIGN</code> loop for the desired level of redundancy,
followed by the establishment of a data channel as described in
data-channels.</p>
<p>However, this method can introduce a significant amount of latency for
completing a full upload that increases linearly with the number of redundant
shards. Additionally, the amount of bandwidth consumed by the renter increases
in the same way as the renter will have to upload the data for each redundant
shard.</p>
<h4>MIRROR</h4>
<p>In these scenarios, renters can offload the burden of storing multiple copies
of a shard to the farmers by issuing a <code>MIRROR</code> RPC in lieu of establishing
a data channel. A <code>MIRROR</code> RPC instructs a contracted farmer to retrieve the
data already uploaded to another farmer by providing them with a retrieval
token authorized by another farmer (this is performed by issuing a <code>RETRIEVE</code>
RPC message - see <em>Downloading Consigned Data</em> later in this document). This
allows the renter to incur the bandwidth and latency once and instead pay the
recently contracted farmer to transfer the data to another farmer for
redundancy.</p>
<p>To initiate this process, instead of opening a data channel, issue a <code>MIRROR</code>
RPC message to the farmer after contract negotiation is complete:</p>
<pre class="prettyprint source"><code>{
  &quot;method&quot;: &quot;MIRROR&quot;,
  &quot;params&quot;: {
    &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;,
    &quot;token&quot;: &quot;ce898e520cede42fd847ba5176b6d6b6ea47481f&quot;,
    &quot;farmer&quot;: {
      &quot;address&quot;: &quot;remote.farmer.host&quot;,
      &quot;port&quot;: 4000,
      &quot;nodeID&quot;: &quot;e77e46ceb7f8dbf2904eff254a479f90a4f8ddbd&quot;,
      &quot;protocol&quot;: &quot;0.8.1&quot;
    },
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.2&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.8.1&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}
</code></pre>
<blockquote>
<p>Note that you should wait until data is successfully consigned to the first
farmer before sending a <code>MIRROR</code> RPC for replication.</p>
</blockquote>
<p>Once the mirroring farmer receives the request, it should open a data channel
to the original farmer and pass along the supplied token and data hash in the
initial authorization frame. Once the mirroring farmer begins receiving data
it must respond to the renter's request with a simple acknowledgement to
indicate that the mirror operation was successfully initiated.</p>
<pre class="prettyprint source"><code>{
  &quot;result&quot;: {
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.2&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.8.1&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}
</code></pre>
<blockquote>
<p>Note that data transfer may fail after the original acknowledgement. It is
important to regularly issue <code>AUDIT</code> messages to farmers storing your data.
If a mirror farmer later fails an audit, the renter should negotiate a new
contract and attempt to create a new mirror to retain the expected level of
redundancy.</p>
</blockquote>
<h3>Auditing a Storage Contract</h3>
<p>Before a renter issues a <code>CONSIGN</code> RPC, it must pre-calculate a series of
&quot;challenges&quot;, the number of which must equal the <code>audit_count</code> defined in the
negotiated contract. A challenge is simply 32 random bytes encoded as hex. The
generated challenges must not be shared until the renter wishes to issue an
<code>AUDIT</code> request.</p>
<p>When issuing a <code>CONSIGN</code> request, the renter must include an <code>audit_tree</code> which
contains the bottom leaves of a merkle tree. Each of the bottom leaves of the
tree must be equal to the double <code>RIPEMD160(SHA256(challenge + shard))</code> encoded
as hex. In order to ensure that the resulting merkle tree is properly
&quot;balanced&quot;, the number of bottom leaves must be equal to the next power of 2 of
the audit count. To ensure this, the additional leaves can simply be the double
<code>RIPEMD160(SHA256(''))</code> (the same hash function for an audit, but applied to an
empty buffer).</p>
<h4>AUDIT</h4>
<p>To audit a farmer is to request proof that it is still honoring the terms of
the storage contract without the need to have them supply the entire
<code>data_shard</code>. To do this, the renter must supply the farmer with one of the
secret pre-calculated challenges:</p>
<pre class="prettyprint source"><code>{
  &quot;method&quot;: &quot;AUDIT&quot;,
  &quot;params&quot;: {
    &quot;audits&quot;: [
      {
        &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;,
        &quot;challenge&quot;: &quot;6290bb9e1766bf3fc00eea3bb14146925611026d453e1aa95c32973f8baa5c98&quot;
      }
    ],
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.2&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.8.1&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}
</code></pre>
<p>Upon receipt of an <code>AUDIT</code> request, the farmer must lookup the <code>data_shard</code> by
the supplied <code>data_hash</code>, then calculate the <em>single</em>
<code>RIPEMD160(SHA256(challenge + shard))</code>.</p>
<blockquote>
<p>The result of this operation should hash again to match one of the items
supplied in the <code>audit_tree</code> property of the original <code>CONSIGN</code> request.</p>
</blockquote>
<p>In addition to supplying this single-hashed value as proof that the farmer is still honoring
the terms of the contract, the farmer must <em>also</em> provide the uncles required
to rebuild the merkle tree. This <strong>proof</strong> response is specified as a series
of nested JSON arrays:</p>
<pre class="prettyprint source"><code>{
  &quot;result&quot;: {
    &quot;proofs&quot;: [
      [[[
      [[&quot;6a2f02144c461e178dc4496c263313e64d7a56ab&quot;
      ],&quot;efb0dfa48813e3289ba8d16e9e23cf1efa1a99fd&quot;
      ],&quot;dfb8877b84e7a7496a4b08b2aef6ffd02ccbfccc&quot;
      ],&quot;82c60f546bcaaabeb908c911b1fadb816e039409&quot;
      ],&quot;5e265b0256cd471c6af22bd66b59ed9242067654&quot;]
    ],
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.2&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.8.1&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}
</code></pre>
<p>For clarification, given a simple merkle tree:</p>
<pre class="prettyprint source"><code>+-- Hash_0 (Root)
|   +-- Hash_1
|   |   +-- Hash_3
|   |   +-- Hash_4
|   +-- Hash_2
|   |   +-- Hash_5
|   |   +-- Hash_6 = RIPEMD160(SHA256(RIPEMD160(SHA256(challenge + shard))))
</code></pre>
<p>The resulting format of a proof for an audit matching Hash_6 would appear as:</p>
<pre class="prettyprint source"><code>[Hash_1, [Hash_5, [RIPEMD160(SHA256(challenge + shard))]]]
</code></pre>
<p>And, the resulting format of a proof for an audit matching Hash_3 would appear as:</p>
<pre class="prettyprint source"><code>[[[RIPEMD160(SHA256(challenge + shard))], Hash_5], Hash_2]
</code></pre>
<p>Upon receipt of the farmer's proof, the renter must verify that the proof is
valid by using it to rebuild the merkle tree. See <a href="Verification.html#verify">Verification#verify</a>
for an implementation example. If the proof is verified successfully, then the
renter is expected to issue a payment to the <code>payment_destination</code> defined in
the original contract. The amount of the payment should be equal to:</p>
<pre class="prettyprint source"><code>(payment_storage_price / audit_count) + (payment_download_price * downloads_since_last_audit)
</code></pre>
<p>If the verification fails then the contract is null and no payment is required.
Conversely, if the verification succeeds and the renter does not issue the
payment in a timely manner, then the contract is also null and the farmer may
decide to cease storage of the data.</p>
<h4>RETRIEVE</h4>
<p>When a renter wishes to retrieve data that is stored under contract, it can
issue a <code>RETRIEVE</code> RPC message that includes the <code>data_hash</code> to the farmer
storing the data:</p>
<pre class="prettyprint source"><code>{
  &quot;method&quot;: &quot;RETRIEVE&quot;,
  &quot;params&quot;: {
    &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;,
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.2&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.8.1&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}
</code></pre>
<p>After the recipient of the <code>RETRIEVE</code> message verifies the sender's signature
it must lookup the storage contract by the supplied <code>data_hash</code> and verify that
the sender is the party with which the contract was negotiated. If all tests
pass, then the farmer must respond with a generated token to allow the renter
to open a data channel (via websocket) to retrieve the data as a binary stream.
After the data shard is delivered successfully, the farmer must increment
it's record of the <code>downloads_since_last_audit</code> (which must be reset after the
next audit).</p>
<blockquote>
<p>For more information on the Data Channel specification see the tutorial for
data-channels.</p>
</blockquote>
<pre class="prettyprint source"><code>{
  &quot;result&quot;: {
    &quot;token&quot;: &quot;3f62b781e3b5b5288dca587807248261d109bbfb&quot;,
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.2&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.8.1&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}
</code></pre>
<p>In addition, the renter must check the integrity of the returned <code>data_shard</code>
by calculating the hash and checking it against the expected <code>data_hash</code>. If
the test fails, then this effectively a failed audit and the contract is null.</p>
<h3>Implemented SIPs</h3>
<ul>
<li><a href="https://github.com/Storj/sips/blob/master/sip-0003.md">SIP0003 Remote Notifications and Triggers</a></li>
<li><a href="https://github.com/Storj/sips/blob/master/sip-0004.md">SIP0004 Contract Transfers and Renewals</a></li>
<li><a href="https://github.com/Storj/sips/blob/master/sip-0032.md">SIP0032 Hierarchically Deterministic Node IDs</a></li>
</ul>
</article>

</section>

</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-storj.html">storj</a></li><li><a href="module-storj_constants.html">storj/constants</a></li><li><a href="module-storj_deps.html">storj/deps</a></li><li><a href="module-storj_patches.html">storj/patches</a></li><li><a href="module-storj_sips.html">storj/sips</a></li><li><a href="module-storj_sips_0003.html">storj/sips/0003</a></li><li><a href="module-storj_utils.html">storj/utils</a></li><li><a href="module-storj_version.html">storj/version</a></li></ul><h3>Classes</h3><ul><li><a href="AuditStream.html">AuditStream</a></li><li><a href="Blacklist.html">Blacklist</a></li><li><a href="BridgeClient.html">BridgeClient</a></li><li><a href="Contact.html">Contact</a></li><li><a href="Contract.html">Contract</a></li><li><a href="DataCipherKeyIv.html">DataCipherKeyIv</a></li><li><a href="DecryptStream.html">DecryptStream</a></li><li><a href="DeterministicKeyIv.html">DeterministicKeyIv</a></li><li><a href="EmbeddedStorageAdapter.html">EmbeddedStorageAdapter</a></li><li><a href="EncryptStream.html">EncryptStream</a></li><li><a href="ExchangeReport.html">ExchangeReport</a></li><li><a href="FarmerInterface.html">FarmerInterface</a></li><li><a href="FileDemuxer.html">FileDemuxer</a></li><li><a href="FileMuxer.html">FileMuxer</a></li><li><a href="KeyPair.html">KeyPair</a></li><li><a href="KeyRing.html">KeyRing</a></li><li><a href="Monitor.html">Monitor</a></li><li><a href="Network.html">Network</a></li><li><a href="OfferManager.html">OfferManager</a></li><li><a href="OfferStream.html">OfferStream</a></li><li><a href="ProofStream.html">ProofStream</a></li><li><a href="Protocol.html">Protocol</a></li><li><a href="RAMStorageAdapter.html">RAMStorageAdapter</a></li><li><a href="RenterInterface.html">RenterInterface</a></li><li><a href="ShardServer.html">ShardServer</a></li><li><a href="StorageAdapter.html">StorageAdapter</a></li><li><a href="StorageItem.html">StorageItem</a></li><li><a href="StorageManager.html">StorageManager</a></li><li><a href="StorageMigration.html">StorageMigration</a></li><li><a href="Transport.html">Transport</a></li><li><a href="TriggerManager.html">TriggerManager</a></li><li><a href="UploadState.html">UploadState</a></li><li><a href="Verification.html">Verification</a></li></ul><h3>Events</h3><ul><li><a href="AuditStream.html#event:finish">finish</a></li><li><a href="DecryptStream.html#event:data">data</a></li><li><a href="DecryptStream.html#event:end">end</a></li><li><a href="EmbeddedStorageAdapter.html#event:add">add</a></li><li><a href="EmbeddedStorageAdapter.html#event:delete">delete</a></li><li><a href="EmbeddedStorageAdapter.html#event:ready">ready</a></li><li><a href="EmbeddedStorageAdapter.html#event:update">update</a></li><li><a href="EncryptStream.html#event:data">data</a></li><li><a href="EncryptStream.html#event:end">end</a></li><li><a href="FarmerInterface.html#event:connected">connected</a></li><li><a href="FarmerInterface.html#event:disconnected">disconnected</a></li><li><a href="FarmerInterface.html#event:error">error</a></li><li><a href="FarmerInterface.html#event:ready">ready</a></li><li><a href="FarmerInterface.html#event:unhandledOffer">unhandledOffer</a></li><li><a href="FarmerInterface.html#event:unhandledOfferResolved">unhandledOfferResolved</a></li><li><a href="FileDemuxer.html#event:finish">finish</a></li><li><a href="FileDemuxer.html#event:shard">shard</a></li><li><a href="FileMuxer.html#event:drain">drain</a></li><li><a href="Monitor.html#event:update">update</a></li><li><a href="Network.html#event:connected">connected</a></li><li><a href="Network.html#event:disconnected">disconnected</a></li><li><a href="Network.html#event:error">error</a></li><li><a href="Network.html#event:ready">ready</a></li><li><a href="Network.html#event:unhandledOffer">unhandledOffer</a></li><li><a href="Network.html#event:unhandledOfferResolved">unhandledOfferResolved</a></li><li><a href="OfferStream.html#event:data">data</a></li><li><a href="OfferStream.html#event:end">end</a></li><li><a href="OfferStream.html#event:error">error</a></li><li><a href="RAMStorageAdapter.html#event:add">add</a></li><li><a href="RAMStorageAdapter.html#event:delete">delete</a></li><li><a href="RAMStorageAdapter.html#event:ready">ready</a></li><li><a href="RAMStorageAdapter.html#event:update">update</a></li><li><a href="RenterInterface.html#event:connected">connected</a></li><li><a href="RenterInterface.html#event:disconnected">disconnected</a></li><li><a href="RenterInterface.html#event:error">error</a></li><li><a href="RenterInterface.html#event:ready">ready</a></li><li><a href="RenterInterface.html#event:unhandledOffer">unhandledOffer</a></li><li><a href="RenterInterface.html#event:unhandledOfferResolved">unhandledOfferResolved</a></li><li><a href="ShardServer.html#event:error">error</a></li><li><a href="ShardServer.html#event:shardDownloaded">shardDownloaded</a></li><li><a href="ShardServer.html#event:shardUploaded">shardUploaded</a></li><li><a href="StorageAdapter.html#event:add">add</a></li><li><a href="StorageAdapter.html#event:delete">delete</a></li><li><a href="StorageAdapter.html#event:ready">ready</a></li><li><a href="StorageAdapter.html#event:update">update</a></li><li><a href="Transport.html#event:connectionLimitReached">connectionLimitReached</a></li><li><a href="UploadState.html#event:killed">killed</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-command-line-interface.html">Using the Command Line Tools</a></li><li><a href="tutorial-contract-topics.html">Publishing Storage Contracts</a></li><li><a href="tutorial-data-transfer.html">Transferring File Shards</a></li><li><a href="tutorial-environment-variables.html">Environment Variables</a></li><li><a href="tutorial-file-encryption.html">File Encryption Standards</a></li><li><a href="tutorial-private-testnet.html">Running a Test Network</a></li><li><a href="tutorial-protocol-spec.html">Protocol Specification</a></li><li><a href="tutorial-renting-data.html">Renting Data to the Network</a></li><li><a href="tutorial-tunnel-connections.html">Tunnelling Connections</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.11</a> on Sat Nov 09 2024 22:26:40 GMT-0800 (Pacific Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>