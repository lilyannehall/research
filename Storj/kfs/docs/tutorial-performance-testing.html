<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Tutorial: Performance Testing the Changes</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Tutorial: Performance Testing the Changes</h1>

    <section>

<header>
    

    <h2>Performance Testing the Changes</h2>
</header>

<article>
    <p>One major hypothesis of this project is that KFS enhances performance over
the use a of a standard LevelDB instance. This is due to the nature of how
KFS bounds the cost of LevelDB's compaction mechanism by sharding a data set
over a series of size-capped LevelDB instances. A set of performance tests
were run on a standard LevelDB along with our version which leverages KFS.
This is a short summary of our findings and their implications.</p>
<h3>Experiment Design</h3>
<p>A series of one hundred trials were run in sequential order.
Each trial consisted of measuring the execution time for a complete read,
write, and unlink (delete) operation on file sizes of 8, 16, 32, 64, 128, 256
and 512 MiB. Keeping in mind that files are split into discrete 128KiB key/value
pairs, keyed by a hash of the content of the entire file, this means that the
actual number of read/write/delete operations are equal to the size of the file
divided by 128KiB.</p>
<p>Of particular note is that each sequential test run adds approximately 1GiB to
the full size of the database (since unlinks only tombstone entries). Our
number of trials is consistent with our assertion that LevelDBs performance
degrades significantly after the size of the database exceeds 100GiB.</p>
<p>This experiment was conducted for both a vanilla (standard) LevelDB and a
version using the KFS protocol. In addition we ran the experiment using
a hard disk drive (HDD) and solid state drive (SSD).</p>
<h3>Results</h3>
<p>An overview plot displaying the execution time by file size and operation for
each trial indicates some difference between KFS and a vanilla LevelDB. At a
high level it appears vanilla LevelDB had a higher variance across many
categories. It is our belief that this variance is due to compaction triggering
in LevelDB as the size of the single instance grows quickly.</p>
<p>Since data is spread in a uniform fashion across a series of LevelDBs in KFS,
this compaction triggering happens less frequently and has a much smaller
impact.</p>
<hr>
<p><img src="doc/img/performance-test-overview-kfs-vs-vanilla-ssd-128.png" alt="Summary Chart SSD"></p>
<p><img src="doc/img/performance-test-overview-kfs-vs-vanilla-hdd-128.png" alt="Summary Chart HDD"></p>
<hr>
<p>Upon closer inspection the data shows that in every category the mean execution
time is lower for KFS for all categories. As for variance, the story is a bit more
complicated. On SSD vanilla LevelDB has much greater variance than KFS for writes and
unlinks but more consistent for reads. On HDD both KFS and vanilla show greater
variance, but again KFS performs more consistently on writes and unlinks.</p>
<hr>
<p>Mean execution time comparison for SSD and HDD.</p>
<p><img src="doc/img/mean-by-operation-and-db-ssd-128.png" alt="Mean Comparison SSD"></p>
<p><img src="doc/img/mean-by-operation-and-db-hdd-128.png" alt="Mean Comparison HDD"></p>
<p>Standard deviation execution time comparison for SSD and HDD.</p>
<p><img src="doc/img/sd-by-operation-and-db-ssd-128.png" alt="Standard Deviation Comp SSD"></p>
<p><img src="doc/img/sd-by-operation-and-db-hdd-128.png" alt="Standard Deviation Comp HDD"></p>
<hr>
<p>We ran two sided
<a href="http://www.stat.yale.edu/Courses/1997-98/101/sigtest.htm">significant tests</a>
on each combination of operation and file size with a p-value cut-off at .05.
For reads at 8, 16, 32, 64, 128 and 256 MiB file sizes, along with unlinks at 64 MiB we are
unable to reject the null hypothesis. Or in other words, we are unable to suggest KFS
performs better than a vanilla LevelDb in those scenarios. For the rest, we did achieve
a 95% confidence level. This suggests that our measurements are not the
result of a statistical fluke and KFS introduces meaningful change for those operations
and file sizes. Please note that any confidence level of 100% is an artifact of rounding.
In this scenario a p-value of 0 is theoretically impossible.</p>
<hr>
<p><img src="doc/img/kfs-vs-vanilla-two-sided-test-128.png" alt="Two Sided Test"></p>
<h3>Conclusion</h3>
<p>While P-Values should not be followed blindly, the data does indicate that
the KFS protocol gives statistically significant gains in speed and consistency.</p>
<p>To reproduce the data generated for these tests:</p>
<ul>
<li>Clone this git repository</li>
<li>Make sure you have Node.js and NPM installed</li>
<li>Run <code>npm install</code> from the project root directory</li>
<li>Run <code>npm run benchmark [iterations] [path_to_write_results]</code></li>
</ul>
<p>You can set the path to the database to create using the <code>KFS_PERF_DIR</code>
environment variable for testing on different types of drives. If no path to
write results to is specified, they will be written to stdout.</p>
<p>If you want to experiment with chunk size (discrete key/value pairs associated
with a file), modify the <code>C</code> constant in <code>lib/constants.js</code>.</p>
</article>

</section>

</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-kfs.html">kfs</a></li><li><a href="module-kfs_constants.html">kfs/constants</a></li><li><a href="module-kfs_utils.html">kfs/utils</a></li></ul><h3>Classes</h3><ul><li><a href="BlockStream.html">BlockStream</a></li><li><a href="Btable.html">Btable</a></li><li><a href="ReadableFileStream.html">ReadableFileStream</a></li><li><a href="Sbucket.html">Sbucket</a></li><li><a href="WritableFileStream.html">WritableFileStream</a></li></ul><h3>Events</h3><ul><li><a href="BlockStream.html#event:data">data</a></li><li><a href="BlockStream.html#event:end">end</a></li><li><a href="ReadableFileStream.html#event:data">data</a></li><li><a href="ReadableFileStream.html#event:end">end</a></li><li><a href="ReadableFileStream.html#event:error">error</a></li><li><a href="ReadableFileStream.html#event:readable">readable</a></li><li><a href="Sbucket.html#event:close">close</a></li><li><a href="Sbucket.html#event:idle">idle</a></li><li><a href="Sbucket.html#event:locked">locked</a></li><li><a href="Sbucket.html#event:open">open</a></li><li><a href="Sbucket.html#event:unlocked">unlocked</a></li><li><a href="WritableFileStream.html#event:error">error</a></li><li><a href="WritableFileStream.html#event:finish">finish</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-about.html">Motivation and Mechanics</a></li><li><a href="tutorial-cli.html">Command Line Interface</a></li><li><a href="tutorial-kfs.html">Programmatic Usage</a></li><li><a href="tutorial-performance-testing.html">Performance Testing the Changes</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.11</a> on Sat Nov 09 2024 15:21:40 GMT-0800 (Pacific Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>