<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: lib/utils.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: lib/utils.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @module kfs/utils
 */

'use strict';

const assert = require('assert');
const constants = require('./constants');
const fs = require('fs');
const crypto = require('crypto');
const path = require('path');

/**
 * A stubbed noop function
 */
module.exports.noop = function() {};

/**
 * Tests if the string is a valid key
 * @param {String} key - The file key
 * @returns {Boolean}
 */
module.exports.isValidKey = function(key) {
  let keyBuffer;

  try {
    keyBuffer = Buffer(key, 'hex');
  } catch (err) {
    return false;
  }

  return keyBuffer.length === (constants.R / 8);
};

/**
 * Hashes the given key
 * @param {String} key - The file key
 * @returns {String}
 */
module.exports.hashKey = function(key) {
  if (module.exports.isValidKey(key)) {
    return key;
  }

  return crypto.createHash(constants.HASH).update(key).digest('hex');
};

/**
 * Coerces input into a valid file key
 * @param {String} key - The file key
 * @returns {String}
 */
module.exports.coerceKey = function(key) {
  if (!module.exports.isValidKey(key)) {
    return module.exports.hashKey(key);
  }

  return key;
};

/**
 * Get the key name for a data hash + index
 * @param {String} key - Hash of the data
 * @param {Number} index - The index of the file chunk
 * @returns {String}
 */
module.exports.createItemKeyFromIndex = function(key, index) {
  assert(typeof index === 'number', 'Invalid index supplied');

  const fileKey = module.exports.hashKey(key);
  const indexLength = Math.floor(constants.S / constants.C).toString().length;
  const indexString = index.toString();

  let itemIndex = '';

  assert(Buffer(fileKey, 'hex').length * 8 === constants.R, 'Invalid key');
  assert(indexString.length &lt;= indexLength, 'Index is out of bounds');

  for (var i = 0; i &lt; indexLength - indexString.length; i++) {
    itemIndex += '0';
  }

  itemIndex += indexString;

  return `${fileKey} ${itemIndex}`;
};

/**
 * Get the file name of an s bucket based on it's index
 * @param {Number} sBucketIndex - The index fo the bucket in the B-table
 * @returns {String}
 */
module.exports.createSbucketNameFromIndex = function(sBucketIndex) {
  assert(typeof sBucketIndex === 'number', 'Invalid index supplied');

  const indexLength = constants.B.toString().length;
  const indexString = sBucketIndex.toString();

  let leadingZeroes = '';

  for (var i = 0; i &lt; indexLength - indexString.length; i++) {
    leadingZeroes += '0';
  }

  return `${leadingZeroes}${indexString}.s`;
};

/**
 * Creates a random reference ID
 * @param {String} [rid] - An existing hex reference ID
 * @returns {String}
 */
module.exports.createReferenceId = function(rid) {
  if (!rid) {
    rid = crypto.randomBytes(constants.R / 8).toString('hex');
  }

  assert(rid.length === 40, 'Invalid reference ID length');

  return Buffer.from(rid, 'hex');
};

/**
 * Check if the given path exists
 * @param {String} filePath
 * @returns {Boolean}
 */
module.exports.fileDoesExist = function(filePath) {
  try {
    fs.statSync(filePath);
  } catch (err) {
    return false;
  }

  return true;
};

/**
 * Takes a number of bytes and outputs a human readable size
 * @param {Number} bytes - The number of bytes to make readable
 * @returns {String}
 */
module.exports.toHumanReadableSize = function(bytes) {
  const thresh = 1024;

  if (Math.abs(bytes) &lt; thresh) {
    return bytes + ' B';
  }

  const units = ['KiB','MiB','GiB','TiB','PiB','EiB','ZiB','YiB'];
  let u = -1;

  do {
    bytes /= thresh;
    ++u;
  } while (Math.abs(bytes) >= thresh &amp;&amp; u &lt; units.length - 1);

  return `${bytes.toFixed(1)} ${units[u]}`;
};

/**
 * Ensures that the given path has a kfs extension
 * @param {String} tablePath - The path name to a kfs instance
 * @returns {String}
 */
module.exports.coerceTablePath = function(tablePath) {
  if (path.extname(tablePath) !== '.kfs') {
    return `${tablePath}.kfs`;
  }

  return tablePath;
};

/**
 * Determines if the passed error object is a NotFound error
 * @param {Error} error
 * @returns {Boolean}
 */
module.exports.isNotFoundError = function(error) {
  return error &amp;&amp; error.message.indexOf('NotFound:') !== -1;
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-kfs.html">kfs</a></li><li><a href="module-kfs_constants.html">kfs/constants</a></li><li><a href="module-kfs_utils.html">kfs/utils</a></li></ul><h3>Classes</h3><ul><li><a href="BlockStream.html">BlockStream</a></li><li><a href="Btable.html">Btable</a></li><li><a href="ReadableFileStream.html">ReadableFileStream</a></li><li><a href="Sbucket.html">Sbucket</a></li><li><a href="WritableFileStream.html">WritableFileStream</a></li></ul><h3>Events</h3><ul><li><a href="BlockStream.html#event:data">data</a></li><li><a href="BlockStream.html#event:end">end</a></li><li><a href="ReadableFileStream.html#event:data">data</a></li><li><a href="ReadableFileStream.html#event:end">end</a></li><li><a href="ReadableFileStream.html#event:error">error</a></li><li><a href="ReadableFileStream.html#event:readable">readable</a></li><li><a href="Sbucket.html#event:close">close</a></li><li><a href="Sbucket.html#event:idle">idle</a></li><li><a href="Sbucket.html#event:locked">locked</a></li><li><a href="Sbucket.html#event:open">open</a></li><li><a href="Sbucket.html#event:unlocked">unlocked</a></li><li><a href="WritableFileStream.html#event:error">error</a></li><li><a href="WritableFileStream.html#event:finish">finish</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-about.html">Motivation and Mechanics</a></li><li><a href="tutorial-cli.html">Command Line Interface</a></li><li><a href="tutorial-kfs.html">Programmatic Usage</a></li><li><a href="tutorial-performance-testing.html">Performance Testing the Changes</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.11</a> on Sat Nov 09 2024 15:21:40 GMT-0800 (Pacific Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
